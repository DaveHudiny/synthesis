mdp

const int N=8;
const int xMIN = 1;
const int yMIN = 1;
const int xMAX = N;
const int yMAX = N;

hole int o1y in {1..4};
hole int o1x_init in {1..4};
hole int goright1_init in {0,1};

hole int o2y in {5..8};
hole int o2x_init in {1..4};
hole int goright2_init in {0,1};

hole int o3y in {1..4};
hole int o3x_init in {5..8};
hole int goright3_init in {0,1};

hole int o4y in {5..8};
hole int o4x_init in {5..8};
hole int goright4_init in {0,1};

const NUM_OBS = 4;
formula crash = visit1 | visit2 | visit3 | visit4;
formula goal = (x=xMAX & y=yMAX);
formula done = goal | crash;


formula clk_next = mod(clk+1,2*NUM_OBS+1);
module clk
    clk : [-1..2*NUM_OBS] init -1;

    [place] !done & clk=-1 -> (clk'=clk_next);

    [left]  !done & clk=0 -> (clk'=clk_next);
    [right] !done & clk=0 -> (clk'=clk_next);
    [down]  !done & clk=0 -> (clk'=clk_next);
    [up]    !done & clk=0 -> (clk'=clk_next);
    [wait]  !done & clk=0 -> (clk'=clk_next);

    [o1]      !done & clk=1 -> (clk'=clk_next);
    [detect1] !done & clk=2 -> (clk'=clk_next);
    
    [o2]      !done & clk=3 -> (clk'=clk_next);
    [detect2] !done & clk=4 -> (clk'=clk_next);

    [o3]      !done & clk=5 -> (clk'=clk_next);
    [detect3] !done & clk=6 -> (clk'=clk_next);

    [o4]      !done & clk=7 -> (clk'=clk_next);
    [detect4] !done & clk=8 -> (clk'=clk_next);
endmodule


const double slip = 0.2;

formula xright  = min(x+1,xMAX);
formula xleft   = max(x-1,xMIN);
formula yup     = min(y+1,yMAX);
formula ydown   = max(y-1,yMIN);

module agent
    x : [xMIN..xMAX] init xMIN;
    y : [yMIN..yMAX] init yMIN;

    [left]  true -> 1-slip : (x'=xleft)  + slip : true;
    [right] true -> 1-slip : (x'=xright) + slip : true;
    [down]  true -> 1-slip : (y'=ydown)  + slip : true;
    [up]    true -> 1-slip : (y'=yup)    + slip : true;
    [wait]  true -> true;
endmodule


formula at1 = (x=o1x & y=o1y);

module obstacle1
    o1x : [xMIN..xMAX] init xMIN;
    goright1 : bool init true;

    [place] true -> (o1x'=o1x_init) & (goright1'=goright1_init=1);

    [o1]  goright1 & o1x < o1x_init_MAX -> 1/2: (o1x'=min(o1x+1,o1x_init_MAX)) + 1/2: true;
    [o1]  goright1 & o1x = o1x_init_MAX -> (goright1'=false);

    [o1] !goright1 & o1x > o1x_init_MIN -> 1/2: (o1x'=max(o1x-1,o1x_init_MIN)) + 1/2: true;
    [o1] !goright1 & o1x = o1x_init_MIN -> (goright1'=true);
endmodule

module visit1
    visit1 : bool init false;
    [detect1] true -> (visit1'=at1);
endmodule

formula at2 = (x=o2x & y=o2y);
module obstacle2=obstacle1[o1=o2,o1x=o2x,o1x_init=o2x_init,o1x_init_MIN=o2x_init_MIN,o1x_init_MAX=o2x_init_MAX,goright1=goright2,goright1_init=goright2_init] endmodule
module visit2=visit1[visit1=visit2,detect1=detect2,at1=at2] endmodule

formula at3 = (x=o3x & y=o3y);
module obstacle3=obstacle1[o1=o3,o1x=o3x,o1x_init=o3x_init,o1x_init_MIN=o3x_init_MIN,o1x_init_MAX=o3x_init_MAX,goright1=goright3,goright1_init=goright3_init] endmodule
module visit3=visit1[visit1=visit3,detect1=detect3,at1=at3] endmodule

formula at4 = (x=o4x & y=o4y);
module obstacle4=obstacle1[o1=o4,o1x=o4x,o1x_init=o4x_init,o1x_init_MIN=o4x_init_MIN,o1x_init_MAX=o4x_init_MAX,goright1=goright4,goright1_init=goright4_init] endmodule
module visit4=visit1[visit1=visit4,detect1=detect4,at1=at4] endmodule
